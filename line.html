<!doctype html>
<html>
<!--
   Copyright (c) 2012, Tomi Leppänen
   
   Achtung, die Kurve! clone written in javascript and svg
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.
-->
<head>
<meta charset="UTF-8" />
<meta author="Tomi Leppänen" />
<title></title>
<script type="text/javascript">
/* Some configs */
var breaksOn = true; // is breaking used or not
var wallMode = "deadly"; // valid values are "deadly" and "warp"

/* Constants */
m = Math;
var TURNINGSPEED = 0.1;
var MOVINGSPEED = 2;
var LOOPSPEED = 10;
var FULLCIRCLE = 2*m.PI;
var BETWEENBREAKS = 75;
var BREAKLENGTH = 10;
var NS = "http://www.w3.org/2000/svg"; // SVG namespace

/* Global variables */
var game;
var border;
var timeout;
var cDM; /* Collision Detection Method 
    Because some browsers doesn't follow svg standard completely (yet) */
    
/* Line object (each player has one) */
function line(name,colour,keyL,keyR) {
    this.direction=m.random()*FULLCIRCLE;
    this.oldDirection;
    this.keyL=keyL;
    this.keyR=keyR;
    this.keyDown=false;
    this.name=name;
    this.colour=colour;
    this.breakcounter=BETWEENBREAKS+m.floor(m.random()*BETWEENBREAKS);
    this.break=false;
    this.x;
    this.y;
    this.addPoint = addPoint;
    this.polyline = document.createElementNS(NS,"polyline");
    this.polyline.setAttributeNS(null,"points","");
    this.polyline.setAttributeNS(null,"fill","none");
    this.polyline.setAttributeNS(null,"stroke",colour);
    this.polyline.setAttributeNS(null,"class",name);
    game.appendChild(this.polyline);
}
function addPoint(lobj,x,y,replOld) {
    var points = lobj.polyline.getAttributeNS(null,"points");
    if (replOld == true) {
        points = points.replace(/[\d\.]+,[\d\.]+$/,"");
        lobj.polyline.setAttributeNS(null,"points",points);
    }
    lobj.polyline.setAttributeNS(null,"points",points+" "+x+","+y);
    lobj.x = x;
    lobj.y = y;
}
function splitLine(lobj) {
    lobj.polyline = document.createElementNS(NS,"polyline");
    lobj.polyline.setAttributeNS(null,"points","");
    lobj.polyline.setAttributeNS(null,"fill","none");
    lobj.polyline.setAttributeNS(null,"stroke",lobj.colour);
    lobj.polyline.setAttributeNS(null,"class",lobj.name);
    game.appendChild(lobj.polyline);
}
var player1;

/* Initializing function */
function init() {
    game = document.getElementById("game");
    border = game.getElementById("border");
    if (cDM == undefined) {
        try { // Selecting collision detection method ->
            game.getIntersectionList(game.createSVGRect(),null);
            cDM = "standard";
        } catch (e) {
            try {
                document.elementFromPoint(null,null);
                cDM = "mozilla";
            } catch (e) {
                cDM = "none";
            }
        }
    }
    player1 = new line("player","#0000cd",37,39); // Adding one player
    var x = m.floor(m.random()*600+100);
    var y = m.floor(m.random()*400+100);
    addPoint(player1,x,y,false); // Add starting point
    timeout = setTimeout("main()",LOOPSPEED);
    document.body.addEventListener("keydown",function(e){inputKeyDown(e)},
        true);
    document.body.addEventListener("keyup",function(e){inputKeyUp(e)},true);
}

/* Main loop */
function main() {
    var warped = 0;
    inputLoop(); // Check input system
    if (wallMode == "deadly") 
        border.setAttributeNS(null,"stroke-dasharray","");
    else if (wallMode == "warp") 
        border.setAttributeNS(null,"stroke-dasharray","4 4");
    var player = player1; // As only one player is used
    var sameDirection = false; // New cordinates ->
    if (player.direction == player.oldDirection) sameDirection = true;
    var x = player.x + MOVINGSPEED*m.sin(player.direction);
    var y = player.y + MOVINGSPEED*m.cos(player.direction);
    if (checkForCollision(x,y,player)) { // Collision detection ->
        gameOver();
        addPoint(player,x,y,sameDirection);
        return;
    } else if (wallMode == "warp" && // Warping ->
        (x <= 0 || x >= 800 || y <= 0 || y >= 600)) {
        addPoint(player,x,y,sameDirection);
        if (x <= 0) { x = 800; }
        else if (x >= 800) { x = 0; }
        else if (y <= 0) { y = 600; }
        else if (y >= 600) { y = 0; }
        splitLine(player);
        player.oldDirection="";
        warped = 2;
    }
    if (breaksOn) { // Breaking ->
        if (!player.break && player.breakcounter <= 0) {
            addPoint(player,x,y,sameDirection);
            player.oldDirection="";
            player.break = true;
            player.breakcounter=BREAKLENGTH;
        } else if (player.break && player.breakcounter <= 0) {
            splitLine(player);
            addPoint(player,x,y,false);
            player.break = false;
            player.breakcounter=BETWEENBREAKS+m.floor(
                m.random()*BETWEENBREAKS);
        } else if (!player.break) { 
            addPoint(player,x,y,sameDirection);
            if (warped <= 0) player.oldDirection = player.direction;
            else if (warped > 0) warped--; 
        } else {
            player.x = x;
            player.y = y;
        }
        player.breakcounter--;
    } else { // Normally drawing ->
        addPoint(player,x,y,sameDirection);
        if (warped <= 0) player.oldDirection = player.direction;
        else if (warped > 0) warped--; 
    }
    timeout = setTimeout("main()",50); // Looping
}

/* Check for a collision */
function checkForCollision(x,y,player) {
    if (cDM == "standard") { // Buggy 
        var rect = game.createSVGRect();
        rect.height=1;
        rect.width=1;
        rect.x=x;
        rect.y=y;
        var list = game.getIntersectionList(rect,null);
        if (list.length == 1) { // Working around border
            if (list[0] != border) return true;
        } else if (list.lenght > 1) {
            return true;
        }
    } else if (cDM == "mozilla") { // Still buggy!
        var element = document.elementFromPoint(x,y);
        if (element.tagName == "polyline") return true;
    }
    if (wallMode == "deadly") {
        if (x <= 0 || x >= 800 || y <= 0 || y >= 600) {
            return true;
        }
    }
    return false;
}

/* When a collision happens */
function gameOver() {
    clearTimeout(timeout);
    document.body.removeEventListener("keyup",function(e){inputKeyUp(e)},true);
    document.body.removeEventListener("keydown",function(e){inputKeyDown(e)},
        true);
    var text = document.createElementNS(NS,"text");
    text.setAttributeNS(null,"x","100");
    text.setAttributeNS(null,"y","100");
    text.setAttributeNS(null,"fill","red");
    text.textContent="Game Over!";
    game.appendChild(text);
}

/* Input system */
function inputKeyUp(event) {
    var player = player1; // currently only one player is used
    if (event.which == player.keyDown) {
        player.keyDown = false;
        return false;
    }
    return true;
}
function inputKeyDown(event) {
    var player = player1; // currently only one player is used
    if (event.which == player.keyL || event.which == player.keyR) {
        player.keyDown = event.which;
        return false;
    } if (event.which == 87) {
        if (wallMode == "deadly") wallMode = "warp";
        else if (wallMode == "warp") wallMode = "deadly";
        return false;
    } if (event.which == 66) {
        breaksOn = !breaksOn;
        return false;
    }
    return true;
}
function inputLoop() {
    var player = player1; // currently only one player is used
    if (player.keyDown == player.keyL) {
        var new_direction = player.direction+TURNINGSPEED;
        if (new_direction > 0) player.direction = new_direction+FULLCIRCLE;
        else player.direction = new_direction;
    } else if (player.keyDown == player.keyR) {
        var new_direction = player1.direction-TURNINGSPEED;
        if (new_direction < FULLCIRCLE) {
            player1.direction = new_direction+FULLCIRCLE;
        } else player1.direction = new_direction;
    }
}
</script>
</head>
<body onload="init()">
<svg id="game" version="1.1" xmlns="http://www.w3.org/2000/svg" 
    width="800" height="600">
<rect id="border" width="100%" height="100%" 
    fill="none" stroke="black" stroke-width="1" />
</svg>
</body>
</html>
