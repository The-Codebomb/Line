<!doctype html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="author" content="Tomi Leppänen" />
<title>Line!</title>
<!--
   Copyright (c) 2012, Tomi Leppänen
   Copyright (c) 2012, Anssi "Miffyli" Kanervisto
   
   Achtung, die Kurve! clone written in javascript and svg
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA.
-->
<script type="text/javascript">
/* Some configs */
var breaksOn = true; // is breaking used or not
var wallMode = "deadly"; // valid values are "deadly" and "warp"

/* Constants */
m = Math;
var TURNINGSPEED = 0.1;
var MOVINGSPEED = 2;
var LOOPSPEED = 30;
var FULLCIRCLE = 2*m.PI;
var BETWEENBREAKS = 75;
var BREAKLENGTH = 10;
var WIDTH = 800;	// CHANGE THESE IF YOU CHANGE CANVAS SIZE!
var HEIGHT = 600;
var NS = "http://www.w3.org/2000/svg"; // SVG namespace
var fontSize = 25;
var font = "Courier New, monospace";

/* Global variables */
var game; // SVG element
var border; // Border's SVGrect element
var timeout;
var bots; // Are bots used (for menus) MAY BE REMOVED IN FUTURE
var players = new Array(); // Array for line-objects

/* Line object (each player has one) */
function line(name,colour,keyL,keyR) {
    this.direction=m.random()*FULLCIRCLE;
    this.oldDirection;
    this.keyL=keyL;
    this.keyR=keyR;
    this.keyDown=false;
    this.name=name;
    this.colour=colour;
    this.alive=true;
    this.breakcounter=BETWEENBREAKS+m.floor(m.random()*BETWEENBREAKS);
    this.break=false;
    this.speed=MOVINGSPEED;
    this.x;
    this.y;
    this.d=1;
    this.polyline = document.createElementNS(NS,"polyline");
    this.polyline.setAttributeNS(null,"points","");
    this.polyline.setAttributeNS(null,"fill","none");
    this.polyline.setAttributeNS(null,"stroke",colour);
    this.polyline.setAttributeNS(null,"stroke-width",this.d);
    this.polyline.setAttributeNS(null,"class",name);
    this.circle = document.createElementNS(NS,"circle");
    this.circle.setAttributeNS(null,"r",m.round(this.d/2));
    this.circle.setAttributeNS(null,"fill",colour);
    this.circle.setAttributeNS(null,"class",name);
    game.appendChild(this.polyline);
    game.appendChild(this.circle);
}
/* Adds a point and moves the circle */
function addPoint(lobj,x,y,replOld) { 
    var points = lobj.polyline.getAttributeNS(null,"points");
    if (replOld == true) {
        points = points.replace(/ [\d\.]+,[\d\.]+$/,"");
        lobj.polyline.setAttributeNS(null,"points",points);
    }
    if (points) lobj.polyline.setAttributeNS(null,"points",points+" "+x+","+y);
    else lobj.polyline.setAttributeNS(null,"points",points+x+","+y);
    moveCircle(lobj,x,y);
}
/* Just moves the circle */
function moveCircle(lobj,x,y) { 
    lobj.circle.setAttributeNS(null,"cx",x);
    lobj.circle.setAttributeNS(null,"cy",y);
    lobj.x = x;
    lobj.y = y;
}
/* Begins a new line */
function splitLine(lobj) { 
    lobj.polyline = document.createElementNS(NS,"polyline");
    lobj.polyline.setAttributeNS(null,"points","");
    lobj.polyline.setAttributeNS(null,"fill","none");
    lobj.polyline.setAttributeNS(null,"stroke",lobj.colour);
    lobj.polyline.setAttributeNS(null,"stroke-width",lobj.d);
    lobj.polyline.setAttributeNS(null,"class",lobj.name);
    game.appendChild(lobj.polyline);
}

/* Bonus pick-ups */
function powerUp(type,x,y,lifetime) {
	//FIX ME!
}

/* Creates menu buttons etc. */
function menu() {
	// Needed atm for proper buttons!
	var playBtn, playBtnT;
	var plrBtn, plrBtnT;
	var plr1Set, plr1SetT;
	var plr2Set, plr2SetT;
	var plr3Set, plr3SetT;
	var plr4Set, plr4SetT;
	var plr1Left, plr1Right;
	var plr2Left, plr2Right;
	var plr3Left, plr3Right;
	var plr4Left, plr4Right;
	var nullHolder; // Can be used to make not-changing text/button;
	createButton(WIDTH/4-100, HEIGHT/4-50, 200, 100, "Play", "play", playBtn,
		playBtnT);
	createButton(WIDTH/3*2-100, HEIGHT/4-25, 200, 50, "1 Player",
		"plrAmount",plrBtn, plrBtnT);
	// Button setting functios
	createButton(WIDTH/3*2, HEIGHT/2-25, 80, 50, "Set", "plr1Set", plr1Set, 
        plr1SetT);
	createButton(WIDTH/3*2, HEIGHT/2+35, 80, 50, "Set", "plr2Set", plr2Set, 
        plr2SetT);
	createButton(WIDTH/3*2, HEIGHT/2+95, 80, 50, "Set", "plr3Set", plr3Set, 
        plr3SetT);
	createButton(WIDTH/3*2, HEIGHT/2+155, 80, 50, "Set", "plr4Set", plr4Set,
        plr4SetT);
	
	createText(WIDTH/6, HEIGHT/2 , "Player 1", nullHolder);
	createText(WIDTH/6, HEIGHT/2+60, "Player 2", nullHolder);
	createText(WIDTH/6, HEIGHT/2+120, "Player 3", nullHolder);
	createText(WIDTH/6, HEIGHT/2+180, "Player 4", nullHolder);
	
	createText(WIDTH/3+30, HEIGHT/2-45, "Left", nullHolder);
	createText(WIDTH/2+30, HEIGHT/2-45, "Right", nullHolder);
	
	createText(WIDTH/3+30, HEIGHT/2, String.fromCharCode(pl1btnL), nullHolder);
	createText(WIDTH/3+30, HEIGHT/2+60, String.fromCharCode(pl2btnL), 
        nullHolder);
	createText(WIDTH/3+30, HEIGHT/2+120, String.fromCharCode(pl3btnL), 
        nullHolder);
	createText(WIDTH/3+30, HEIGHT/2+180, String.fromCharCode(pl4btnL), 
        nullHolder);
	
	createText(WIDTH/2+30, HEIGHT/2, String.fromCharCode(pl1btnR), nullHolder);
	createText(WIDTH/2+30, HEIGHT/2+60, String.fromCharCode(pl2btnR), 
        nullHolder);
	createText(WIDTH/2+30, HEIGHT/2+120, String.fromCharCode(pl3btnR), 
        nullHolder);
	createText(WIDTH/2+30, HEIGHT/2+180, String.fromCharCode(pl4btnR), 
        nullHolder);
}

/* Retry menu, which comes when player(s) die */
function retryMenu() {
	var retryBtn, retryBtnT;
	var menuBtn, menuBtnT;
	createButton(WIDTH/2-100, HEIGHT/2-125, 200, 100, "Play again", "retry",
		retryBtn, retryBtnT);
	createButton(WIDTH/2-100, HEIGHT/2+25, 200, 100, "Main Menu", "rtnMenu",
		menuBtn, menuBtnT);
}

/* Create button with text and eventlistener */
function createButton(x,y,width,height,text,btnType,btn,btnText) {
	btn = document.createElementNS(NS,"rect");
	btn.setAttributeNS(null, "x", x);
	btn.setAttributeNS(null, "y", y);
	btn.setAttributeNS(null, "width", width);
	btn.setAttributeNS(null, "height", height);
	btn.setAttributeNS(null, "fill", "#FFFFFF");
	btn.setAttributeNS(null, "stroke", "black");
	btn.setAttributeNS(null, "stroke-width", 2);
    
	btnText = document.createElementNS(NS,"text");
	btnText.setAttributeNS(null, "x", x + width / 2);
	btnText.setAttributeNS(null, "y", y + height / 2 + fontSize / 4);
	btnText.setAttributeNS(null, "font-family", font);
	btnText.setAttributeNS(null, "font-size", fontSize);
	btnText.textContent = text;	// Can screw up in other browsers than FF
	btnText.setAttributeNS(null, "text-anchor", "middle");
	
	game.appendChild(btn);
	game.appendChild(btnText);
    
	btn.addEventListener("click", // two listeners, fix this
        function(e){buttonClick(e,btnType,btn,btnText)},false);
	btnText.addEventListener("click",
		function(e){buttonClick(e,btnType,btn,btnText)},false);
	
	btn.addEventListener("mouseover",function(e){buttonHoverOn(e,btn,btnText)},
		false);	// for effects when hovering
	btnText.addEventListener("mouseover",
		function(e){buttonHoverOn(e,btn,btnText)},false);	
	btn.addEventListener("mouseout",function(e){buttonHoverOff(e,btn,btnText)},
		false);	
	btnText.addEventListener("mouseout",function(e){buttonHoverOff(e,btn,
		btnText)},false);
}

/* Create new text with given x/y coordinates etc. */
function createText(x,y,text,writenText) {
	writenText = document.createElementNS(NS,"text");
	writenText.setAttributeNS(null, "x", x);
	writenText.setAttributeNS(null, "y", y + fontSize / 4);
	writenText.setAttributeNS(null, "font-family", font);
	writenText.setAttributeNS(null, "font-size", fontSize);
	writenText.textContent = text;	//Can screw up in other browsers than FF.
	writenText.setAttributeNS(null, "text-anchor", "middle");
	game.appendChild(writenText);
}

/* Initializing function */
function init() { // Will be mostly redone when menus are implemented
    game = document.getElementById("game");
    border = game.getElementById("border");
	menu();
}

/* Starts the game */
function startGame() { // Adding one player -> FIXME
	player1 = new line("player","#0000cd",pl1btnL,pl1btnR); 
    var x = m.floor(m.random()*(WIDTH-200)+100);
    var y = m.floor(m.random()*(HEIGHT-200)+100);
    addPoint(player1,x,y,false); // Add starting point
    timeout = setTimeout("main()",LOOPSPEED); // Start "loop"
    document.body.addEventListener("keydown",function(e){inputKeyDown(e)},
        true); // Begin input ->
    document.body.addEventListener("keyup",function(e){inputKeyUp(e)},true);
}

/* Main "loop" */
function main() {
    var time = (new Date()).getTime(); // To count time of one loop
    var warped = 0;
    if (wallMode == "deadly") // Set the borders if wallMode has changed
        border.setAttributeNS(null,"stroke-dasharray","");
    else if (wallMode == "warp") 
        border.setAttributeNS(null,"stroke-dasharray","4 4");
    for (i in players) {
        var player = players[i];
        if (bots) { // If just bots are playing
            botControl(player);
            if (!player.alive) {
                timeout = setTimeout("botGameOver()",1000);
                return;
            }
        } else inputLoop(player); // Check input system
        var sameDirection = false; // New cordinates ->
        if (player.direction == player.oldDirection) sameDirection = true;
        var x = player.x + player.speed*m.sin(player.direction);
        var y = player.y + player.speed*m.cos(player.direction);
        if (checkForCollision(x,y,player)) { // Collision detection ->
            if (!breaksOn || !player.break) {
                spillBlood(x,y);
                gameOver();
                if (!bots) return; else timeout=true;
            }
        } else if (wallMode == "warp" && // Warping ->
            (x <= 0 || x >= 800 || y <= 0 || y >= 600)) {
            addPoint(player,x,y,sameDirection);
            if (x <= 0) { x = 800; }
            else if (x >= 800) { x = 0; }
            else if (y <= 0) { y = 600; }
            else if (y >= 600) { y = 0; }
            splitLine(player);
            player.oldDirection="";
            warped = 2;
        }
        if (breaksOn) { // Breaking ->
            if (!player.break && player.breakcounter <= 0) {
                addPoint(player,x,y,sameDirection);
                player.oldDirection="";
                player.break = true;
                player.breakcounter=BREAKLENGTH;
            } else if (player.break && player.breakcounter <= 0) {
                splitLine(player);
                addPoint(player,x,y,false);
                player.break = false;
                player.breakcounter=BETWEENBREAKS+m.floor(
                    m.random()*BETWEENBREAKS);
            } else if (!player.break) { 
                addPoint(player,x,y,sameDirection);
                if (warped <= 0) player.oldDirection = player.direction;
                else if (warped > 0) warped--; 
            } else {
                moveCircle(player,x,y);
            }
            player.breakcounter--;
        } else { // Normally drawing ->
            addPoint(player,x,y,sameDirection);
            if (warped <= 0) player.oldDirection = player.direction;
            else if (warped > 0) warped--; 
        }
    }
    time = (new Date()).getTime()-time; // Looping ->
    looptime = LOOPSPEED - time;
    if (looptime < 0) looptime = 0;
    if (timeout) timeout = setTimeout("main()",looptime);
}

/* Check for a collision */
function checkForCollision(x,y,player) {
    /*
     * Collision between lines is detected by calculating 
     * points that are common to two segments. Segment means
     * here the part of line between two points.
     *
     * The first segment is the one we just have drawn.
     * To get the other one we must get all lines,
     * then split their points and now we get two points
     * for each segment.
     *
     * So we repeat this to nearly all segments of all lines:
     *  - Calculate x-cordinate that is common to two segments
     *  - Check that the cordinate is part of both segments
     *    - If it is return true (player collided)
     *    - If it isn't continue
     * 
     * The calculations and checks are last lines of this part
     * and all boring stuff is before them.
     */
    var cline = player.polyline.getAttributeNS(null,"points");
    cline = cline.match(/[\d\.]+,[\d\.]+ [\d\.]+,[\d\.]+$/);
    if (cline != null)  {
        cline = cline[0].split(" ");
        var xy = cline[0].split(",");
        var cx = xy.slice(0,1)[0];
        var cy = xy.slice(1,2)[0];
        var dx = x;
        var dy = y;
        var polylines = game.getElementsByTagName("polyline");
        for (var i = 0; i < polylines.length; i++) {
            var points = polylines[i].getAttributeNS(null,"points");
            points = points.split(" ");
            if (polylines[i] == player.polyline) { // Working around the 
                if (points.length > 2) { // player's own segments
                    points = points.splice(0,points.length-2);
                } else points = points.splice(0,0);
            }
            for (var j = 0; j < points.length-1; j++) {
                var eline = new Array(points[j], points[j+1]);
                var xy = eline[0].split(",");
                var ex = xy.slice(0,1)[0];
                var ey = xy.slice(1,2)[0];
                var xy = eline[1].split(",");
                var fx = xy.slice(0,1)[0];
                var fy = xy.slice(1,2)[0];
                if ((ex > cx && fx > cx && ex > dx && fx > dx) || 
                    (ex < cx && fx < cx && ex < dx && fx < dx) ||
                    (ey < cy && fy < cy && ey < dy && fy < dy) ||
                    (ey < cy && fy < cy && ey < dy && fy < dy))
                    continue; // Don't calculate unuseful ones
                var res = (((cx*dy-cy*dx)*(ex-fx)-(cx-dx)*(ex*fy-ey*fx))/
                    ((cx-dx)*(ey-fy)-(cy-dy)*(ex-fx)));
                if ((cx <= res && res <= dx)||(cx >= res && res >= dx)) {
                    if ((ex <= res && res <= fx)||(ex >= res && res >= fx))
                        return true;
                }
            }
        }
    }
    if (wallMode == "deadly") { // Check if player hit the wall
        if (x <= 0 || x >= WIDTH || y <= 0 || y >= HEIGHT) {
            return true;
        }
    }
    return false;
}

/* inputLoop replacement for bot players */
function botControl(bot) { // Needs more intelligent AI(s)
    var keypress=m.random();
    if (bot.bot_direction == undefined) bot.bot_direction=0;
    if (bot.bot_intelligence == "idiot") { // Does whatever she wants
        if ((bot.bot_direction > 0 && bot.bot_direction < 10) 
                || keypress < 0.4) {
            bot.bot_direction++;
            bot.direction = botInputLeft(bot.direction);
        } else if ((bot.bot_direction < 0 && bot.bot_direction > -10) 
                || keypress > 0.6) {
            bot.bot_direction--;
            bot.direction = botInputRight(bot.direction);
        }
        if (bot.bot_direction >= 10 || bot.bot_direction <= -10) 
            bot.bot_direction=0;
    } else if (bot.bot_intelligence == "stupid") { // Has (?) some intelligence
        if (bot.bot_phase == undefined) bot.bot_phase=0;
        if ((!bot.bot_wallZone) && ((bot.x < 50) || (bot.x > 750) || 
                (bot.y < 50) || (bot.y > 550))) {
            bot.bot_direction = -10;
            bot.bot_wallZone=true;
        } else if ((bot.x > 50) && (bot.x < 750) && 
            (bot.y > 50) && (bot.y < 550)) bot.bot_wallZone=false;
        if (bot.bot_phase == 0) {
            bot.bot_direction++;
            bot.direction = botInputLeft(bot.direction);
            if (bot.bot_direction > 20) { 
                bot.bot_phase=1;
                bot.bot_direction=0;
            }
        } else {
            bot.bot_direction++;
            bot.direction = botInputRight(bot.direction);
            if (bot.bot_direction > 20) { 
                bot.bot_phase=0;
                bot.bot_direction=0;
            }
        }
    } else {
        bot.bot_intelligence=(m.random()>=0.5)?"stupid":"idiot";
        bot.bot_intelligence="stupid";
    }
}
function botInputLeft(old_direction) {
    var new_direction = old_direction+TURNINGSPEED;
    if (new_direction > FULLCIRCLE) return new_direction-FULLCIRCLE;
    else return new_direction;
}
function botInputRight(old_direction) {
    var new_direction = old_direction-TURNINGSPEED;
    if (new_direction < 0) return new_direction+FULLCIRCLE;
    else return new_direction;
}

/* When all bots are dead */
function botGameOver() {
            var lines = game.getElementsByTagName("polyline");
            for (var i = lines.length-1; i >= 0; i--) {
                game.removeChild(lines[0]);
            }
            var circles = game.getElementsByTagName("circle");
            for (var i = circles.length-1; i >= 0; i--) {
                game.removeChild(circles[0]);
            }
            game.removeChild(game.getElementById("gameover_text"));
            timeout = setTimeout("init()",1000);
            return;
}

/* The blood effect */
function spillBlood(x,y) {
    var spills = new Array();
    for (var i = 0; i < 50; i++) {
        var nx = m.random()*30+x-15; // Trying to make some randomness
        if (nx < x-5) var ny = m.random()*10+y-10; // and a circular shape
        else if (nx > x+5) var ny = m.random()*10+y;
        else var ny = m.random()*30+y-15;
        spills.push(document.createElementNS(NS,"circle"));
        spills[i].setAttributeNS(null,"r",m.random());
        spills[i].setAttributeNS(null,"fill","red");
        spills[i].setAttributeNS(null,"class","blood");
        spills[i].setAttributeNS(null,"cx",nx);
        spills[i].setAttributeNS(null,"cy",ny);
        game.appendChild(spills[i]);
    }
}

/* When a collision happens (cleaning up and informing user) */
function gameOver() {
    timeout = clearTimeout(timeout);
    document.body.removeEventListener("keyup",function(e){inputKeyUp(e)},true);
    document.body.removeEventListener("keydown",function(e){inputKeyDown(e)},
        true);
    var GOtext = document.createElementNS(NS,"text");
    GOtext.setAttributeNS(null,"x","100");
    GOtext.setAttributeNS(null,"y","100");
    GOtext.setAttributeNS(null,"fill","red");
    GOtext.textContent="Game Over!";
    game.appendChild(GOtext);
	retryMenu();
}

/* changes rect/text settings back to "bold" when hovering above it */
function buttonHoverOn(e,btn,btnText) {
	btnText.setAttributeNS(null, "font-size", fontSize + 2);
	btn.setAttributeNS(null, "stroke-width", 3);
}

/* changes rect/text settings back to normal when not hovering above it */
function buttonHoverOff(e,btn,btnText) {
	btnText.setAttributeNS(null, "font-size", fontSize);
	btn.setAttributeNS(null, "stroke-width", 2);
}

/* Checks which button was clicked, and handles what should happen */
function buttonClick(e,btnType,btn,btnText) {
	if (btnType == "play") {/*
		if (player1) {		// CHANGE FOR MANY PLAYERS!
			clearGround();
		}*/
		removeBtns();
		startGame();
	} else if (btnType == "plrAmount") {
		playerAmount++;
		if (playerAmount == 2) {
			btnText.textContent = "2 Players";
		} else if (playerAmount == 3) {
			btnText.textContent = "3 Players";
		} else if (playerAmount == 4) {
			btnText.textContent = "4 Players";
		} else if (playerAmount == 5) {
			playerAmount = 1;
			btnText.textContent = "1 Player";
		}
	} else if (btnType == "retry") {/*
		if (player1) {		// CHANGE FOR MANY PLAYERS!
			clearGround();
		}*/
		removeBtns();
		startGame();
	} else if (btnType == "rtnMenu") {
		removeBtns();
		playerAmount = 1;
		menu();
	} else if (btnType == "plr1Set") {
		removeBtns();
		setButtons(1);
	} else if (btnType == "plr2Set") {
		removeBtns();
		setButtons(2);
	} else if (btnType == "plr3Set") {
		removeBtns();
		setButtons(3);
	} else if (btnType == "plr4Set") {
		removeBtns();
		setButtons(4);
	}
	
}

/* ??? */
function clearGround() {
	var lines = game.getElementsByTagName("polyline");
	for (i = lines.length - 1; i >= 0;i--) {
		game.removeChild(lines[i]);
	}
			
	var circles = game.getElementsByTagName("circle");
	for (i = circles.length - 1; i >= 0;i--) {
		game.removeChild(circles[i]);
	}
}

/* ??? */
function removeBtns() {
	var rects = game.getElementsByTagName("rect");	// Remove box buttons
	// Keep the first rect, which is border
	for (var i = rects.length - 1; i >= 1;i--) {
		game.removeChild(rects[i]);
	}		
	var texts = game.getElementsByTagName("text");	// Remove texts
	for (var i = texts.length - 1; i >= 0;i--) {
		game.removeChild(texts[i]);
	}
}

/* ??? */
function setButtons(playerNum) {
	// Asking for buttons here
	menu();
}

/* Input system */
function inputKeyUp(event) {
    for (i in players) {
        var player = players[i];
        if (event.which == player.keyDown) {
            player.keyDown = false;
            return false;
        } return true;
    }
}
function inputKeyDown(event) {
    for (i in players) {
        var player = players[i];
        if (event.which == player.keyL || event.which == player.keyR) {
            player.keyDown = event.which;
            return false;
        } if (event.which == 87) {
            if (wallMode == "deadly") wallMode = "warp";
            else if (wallMode == "warp") wallMode = "deadly";
            return false;
        } if (event.which == 66) {
            breaksOn = !breaksOn;
            return false;
        } if (event.which == 75) {
            gameOver();
            return false;
        } return true;
    }
}
function inputLoop(player) {
    if (player.keyDown == player.keyL) {
        var new_direction = player.direction+TURNINGSPEED;
        if (new_direction > FULLCIRCLE) 
            player.direction = new_direction-FULLCIRCLE;
        else player.direction = new_direction;
    } else if (player.keyDown == player.keyR) {
        var new_direction = player.direction-TURNINGSPEED;
        if (new_direction < 0)
            player.direction = new_direction+FULLCIRCLE;
        else player.direction = new_direction;
    }
}
</script>
</head>
<body onload="init()">
<svg id="game" version="1.1" xmlns="http://www.w3.org/2000/svg" 
    width="800" height="600">
<rect id="border" width="100%" height="100%" 
    fill="none" stroke="black" stroke-width="1" />
</svg>
</body>
</html>
